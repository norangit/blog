# SpringBoot 快速上手系列教程（二）



**SpringBoot** 是 **Spring** 官方为了简化开发难度，提升开发效率而打磨的一个造福开发者的全能框架，她天生就是为集成而来，方便集成，快速集成，自动集成。她提供了很多本是生产环境才具有的特性，比如应用监控，代码热修改等。本篇主要介绍强大的日志配置，事务管理，以及在开发过程中经常会遇到的一些代码复用、抽象的小技巧。技巧虽小，却能顶大用的哦。



## SpringBoot 主要入口类配置

**SpringBoot** 有一个主要的入口类，通过该类的 `Main` 方法来启动应用。如：

```java
@SpringBootApplication
@EnableTransactionManagement
public class App {
    private static Logger logger = LogManager.getLogger(App.class);
    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
    		applicationContext = SpringApplication.run(App.class, args);
		}

    public static <T> T getBean(Class<T> clz) {
        return (T) applicationContext.getBean(clz);
    }
  
  	@Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

注解 **[@SpringBootApplication](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-using-springbootapplication-annotation)** 实际上等价于别的 3 个注解的作用：**`@EnableAutoConfiguration`，`@ComponentScan`，`@Configuration`**。

通常不会把所有的额外的配置信息都放在 `App` 类里面，会单独创建特定的配置类，比如 **Spring Security** 的配置，就需要几十行代码，甚至更多，还会有别的配置等。可以简单的配置一些东西，比如配置一个 `RestTemplate`。



### 日志系统

推荐使用 `Log4j2` 日志系统，使用 `spring-boot-starter-log4j2` **Starter**，

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

在 `resources` 目录下新建一个文件：`log4j2-spring.xml`，然后在 **`application.properties`** 文件里指定

```properties
logging.config=classpath:log4j2-spring.xml
#开发阶段可以禁用某些不重要的日志输出，格式为：logging.level. + class 全路径
#减少不必要的日志输出，可以提升效率，高效又环保
logging.level.root=info
logging.level.org.springframework.beans.factory=error
logging.level.org.springframework.web=debug
...
```

生产环境可以参考 `Log4j2` 官方文档，使用 Filter 可以实现精准过滤，[戳这里](https://logging.apache.org/log4j/2.x/manual/filters.html) 。可以参考 druid 的 log4j2 配置然后改成自己想要的 - [ log4j2.xml文件中的日志配置(完整，可直接拷贝使用)](https://github.com/alibaba/druid/wiki/Druid%E4%B8%AD%E4%BD%BF%E7%94%A8log4j2%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA#2-log4j2xml%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%95%B4%E5%8F%AF%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8)。



### 事务管理

**@EnableTransactionManagement** 是启用事务支持的，然后在需要事务的 `Service` 方法上添加相应的注解即可，比如：只读事务 - **@Transactional(readOnly = true)**，`readOnly` 默认是 `false`， 是支持写操作的，在查询方法或者不重要的方法上可以使用只读事务来提升性能。

 **@Transactional** 如果加在 **Class** 上，则当前类的所有方法，当前类的所有子类的方法都会启用默认的事务。懒一点，不考虑性能的话，直接定义一个 **BaseService**，然后把 **@Transactional** 加上，其它的所有具体 Service 继承 **BaseService** 从而继承事务管理。如：

`BaseService.java`

```java
@Transactional
public abstract class BaseService<T extends BaseEntity, ID> {
    protected final Logger logger = LogManager.getLogger(this.getClass());

    @Autowired
    private BaseRepository baseDaoImpl;

    @Autowired
    private EntityManager em;

    @Transactional(readOnly = true)
    public List<T> getAllById(Iterable<ID> ids) {
        return getDao().findAllById(ids);
    }

    @Transactional(readOnly = true)
    public List<T> getAll(int page, int pageSize) {
        return getDao().findAll(PageRequest.of(page, pageSize)).getContent();
    }


    @Transactional(readOnly = true)
    public List<T> getAll(Pageable pageable) {
        return getDao().findAll(pageable).getContent();
    }


    @Transactional(readOnly = true)
    public List<T> getAll() {
        return getDao().findAll();
    }

    @Transactional(readOnly = true)
    public Long total() {
        return this.getDao().count();
    }

    public void deleteById(ID id) {
        this.getDao().deleteById(id);
    }

    public T save(T entity) {
        return this.getDao().save(entity);
    }

    public boolean saveInNativeBatch(List<T> entities) {
        return getDao().saveAll(entities).size() == entities.size();
    }

    @Transactional(readOnly = true)
    public T getById(ID id) {
        return (T) this.getDao().findById(id).get();
    }

    public boolean update(T entity) {
        this.getDao().save(entity);
        return true;
    }

    public void delete(List<T> entities) {
        getDao().deleteInBatch(entities);
    }

    private Class<T> getEntityClass() {
        return (Class<T>) GenericClassUtil.getActualTypeArgument(this.getClass());
    }

    protected abstract BaseDao<T, ID> getDao();
}
```



> 创建一个 **BlogService** 继承 **BaseService**

```java
@Service
public class BlogService extends BaseService<Blog, Long> {
    @Resource
    private BlogDao dao;

    @Transactional(readOnly = true)
    public List<Blog> getEnabledAll(int page, int pageSize){
        logger.info("getEnabledAll: {}, {}", page, pageSize);
        return dao.findByEnabledTrue(PageRequest.of(page, pageSize));
    }

    @Transactional(readOnly = true)
    public List<Blog> getEnabledAll(Pageable pageable){
        logger.info("getEnabledAll: {}", pageable);
        return dao.findByEnabledTrue(pageable);
    }

		public List<Blog> getEnabledAll(){
        logger.info("getEnabledAll: ");
        return dao.findByEnabledTrue(PageRequest.of(0, 10));
    }

    @Transactional(readOnly = true)
    public List<Blog> getByTitle(Pageable pageable, String title){
        return dao.findByTitleContaining(title, pageable);
    }

    @Override
    public Blog save(Blog entity) {
        entity.setCreateDate(new Date());
        super.save(entity);
        return entity;
    }

    @Override
    public boolean update(Blog entity) {
        entity.setUpdateDate(new Date());
        return super.update(entity);
    }

    @Override
    protected BaseDao<Blog, Long> getDao() {
        return dao;
    }
}
```

随便写个 **BlogService** 的 `getEnabledAll()` 方法单元测试跑一跑，看一看日志输出，就能看到该方法也启用了事务，就是继承自 **BaseService**。



### Dao、Service、Controller 都继承一个父类

实际开发中，**Dao、Service、Controller** 都可以继承一个父类，达到复用、减少代码的效果。比如：`BaseDao`、`BaseService`、`BaseController`，都可以定义一个 logger：

```java
protected final Logger logger = LogManager.getLogger(this.getClass());
```

这样子类就可以直接调用 logger 了，因为 `getLogger()` 的参数是 `this.getClass()`，是动态绑定的，也就是继承中的多态，所以当具体子类调用的时候，控制台输出的是具体的子类，而不是父类。

再如：在 `BaseController` 中，除了注入 logger 以外，还可以注入 **Jackson** 的 `ObjectMapper`

```java
@Component
public class BaseController {
    protected final Logger logger = LogManager.getLogger(this.getClass());

    @Autowired
    protected ObjectMapper objectMapper;

    @Autowired
    protected BlogService blogService;

}
```

这样在所有的子 `Controller` 里用到 json <==> object 互转的地方就可以直接调用而不用每个 `Controller` 里都注入了。还可以把常用的 `Service` 都注入到 `BaseController` 里面，省得在子 `Controller` 也要注入。

这些都是一些小技巧，但是却很实用，不仅代码少了，维护也好维护，一个地方维护一切。当然现实中，要求苛刻的地方可能会不允许在父类中注入所有的 Service，但是，如果性能不是问题，那大可以常用的都注入进去，性能都不是问题，那还有什么是问题呢？规则都是人定的，灵活运用即可。



### 系列教程

* [SpringBoot 快速上手系列教程（一)](https://gxfcba.com/a1/blog/5)


# SpringBoot 快速上手系列教程（一）



**SpringBoot** 是 **Spring** 官方为了简化开发难度，提升开发效率而打磨的一个造福开发者的全能框架，她天生就是为集成而来，方便集成，快速集成，自动集成。她提供了很多本是生产环境才具有的特性，比如应用监控，代码热修改等。提供了最佳实践如：代码结构，配置，自动配置，**Spring Beans** 和依赖注入等。为了达到这些简化、自动化，对开发人员极大的便利性背后，**SpringBoot** 做了大量的工作。官方是这样介绍的：

> 官方介绍：

**SpringBoot** 使得创建独立的、面向生产环境的、基于 **Spring** 的应用程序变得易如反掌，简单到可以 “直接运行” 这些应用程序（主要是指 **build** 过程更加简单，方便，提供了基于 **Maven，Gradle** 的 build 组件，一键 build JAR 、WAR，Spring 也提供了命令行）。

对于 **Spring** 平台和第三方类库，我们客观上认为可以轻松地入门。大多数的 **SpringBoot** 应用只需要很少的 **Spring** 配置，不像传统的 **Spring** 需要在 XML 配置文件里配置很多，比如事务配置，注解扫描配置等，**SpringBoot** 都会自动扫描。



> 特性

1. 创建独立的、单独的应用程序
2. 支持直接嵌入式应用服务器（**Tomcat,  Jetty or Undertow**），不需要构建 **war** 部署到应用服务器
3. 提供了方便的的 “**starter**” 依赖项来简化构建配置
4. 总是尽可能地自动配置 **Spring** 和第三方类库
5. 提供生产环境的特性，如应用监控、健康检查和外部化配置
6. 完全不需要代码生成，也不需要额外 **XML** 配置



## 快速上手

可以参考官方文档快速构建一个简单的 **SpringBoot** 应用，[戳这里](https://start.spring.io/)，然后下载下来解压，导入到 IDE 里，推荐使用 [IDEA](https://www.jetbrains.com/idea/download/)，博主也是从 Eclipse 转到 IDEA 的，比起 Eclipse 来非常好用，非常强大。 有社区免费版，也有旗舰版（[可以戳这里查看如何科学使用](https://gxfcba.com/a1/softRes)）。构建工具，本站博客全部使用 **[Maven](https://maven.apache.org/download.cgi)** 构建。



> 目录结构最佳实践

[戳这里看 SpringBoot官方推荐](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#working-with-spring-boot)。建一个根路径包 root，比如：com.gxfcba，然后根路径下建一个主的 Class，通常就叫 App，或者有特定意义的名字，比如 BlogApp：

```java
package com.gxfcba;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement
public class App {
    private static Logger logger = LogManager.getLogger(App.class);
    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = SpringApplication.run(App.class, args);

    }

    public static <T> T getBean(Class<T> clz) {
        return (T) applicationContext.getBean(clz);
    }
}

```



最终的 Class 目录结构看起来是这样的：

```html
com
 +- gxfcba
    +- App.java
    |
		+- base
		|		+- ...
		+- util
		|		+- DateUtils
		|		+- ...
    |
    +- blog
    |   +- Blog.java
    |   +- BlogController.java
    |   +- BlogService.java
    |   +- BlogRepository.java
    |
    +- order
    +- ...
    ...
		...
```



**Spring** 会自动扫描 App.java 所在目录以及所有子目录被添加了能够被她管理的注解的类，如：**`@Component`, `@Service`, `@Repository`, `@Controller`** 等。使用传统的 XML 的话，是需要配置这个属性的，而 **Springboot** 不用。

更加详细的信息建议详细阅读 [SpringBoot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-documentation)，多看几次，就当学习英文了。



> BlogController.java 

```java
package com.gxfcba.blog;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.gxfcba.base.BaseController;
import com.gxfcba.base.MyPageRequest;
import com.gxfcba.base.MyResponse;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
@RequestMapping("/blog")
public class BlogController extends BaseController {

    @GetMapping()
    public ModelAndView index(@PathVariable(required = false) Integer page) throws Exception {
        ModelAndView modelAndView = new ModelAndView("blog/index");

        PageRequest pageRequest = PageRequest.of(page == null ? 0 : page - 1, 5, Sort.by("createDate").descending());

        List<Blog> blogList = blogService.getEnabledAll(pageRequest);
        Long total = blogService.total();

        modelAndView.addObject("blogs", blogList);
        modelAndView.addObject("total", total);

        return modelAndView;
    }

    @PostMapping("/list")
    @ResponseBody
    public MyResponse list(@RequestBody MyPageRequest pageRequest) {
        Map<String, Object> result = new HashMap<>();
        Long filterTotal = 0L;

        if(pageRequest.getConditionList() != null && pageRequest.getConditionList().size() > 0){
            filterTotal = this.blogService.filterTotal(pageRequest);
        }

        result.put("data", this.blogService.getAll(pageRequest));
        result.put("total", this.blogService.total());
        result.put("filterTotal", filterTotal);

        return MyResponse.success(result);
    }

    @PostMapping("/save")
    @ResponseBody
    public MyResponse save(@RequestBody Blog blog) {
        if(blog.getId() == null){
            blogService.save(blog);
        }else{
            blogService.update(blog);
        }

        return MyResponse.success();
    }

    @GetMapping("/del/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @ResponseBody
    public MyResponse delete(@PathVariable Long id) {
        blogService.deleteById(id);

        return MyResponse.success();
    }

    @GetMapping(name = "blog detail page", value = "/{id}")
    public ModelAndView blogDetail(@PathVariable Long id) throws JsonProcessingException {
        ModelAndView modelAndView = new ModelAndView("blog/detail");

        Blog blog = blogService.getById(id);
        int words = 0;

        if (blog.isEnabled()) {
            words = blog.getContent().length();
            modelAndView.addObject("blog", blog);
        } else {
            modelAndView.addObject("berr", true);
        }

        return modelAndView;
    }
}

```



具体的方法信息这里就不列出来了，然后就可以在 IDEA 里启动 App，启动成功了，可以打开浏览器访问 localhost:8080/blog，默认端口是 8080，默认嵌入式 Sever 是 Tomcat。到此，一个简单的 App 就构建完成了，可以使用 Maven 在命令行轻松的打包成 jar。



## 完整的目录结构

到目前为止，都没有用到  **`application.properties`** 或 **`application.yml`**，也没有任何静态文件，html、js

、css 等。实际项目中，如果使用的是 Maven，那么标准目录结构 [戳这里看 Maven 官方说明](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)。

对于一个 Web 应用来说，html 是必不可少的，Spring 不推荐使用 JSP，因为有一些限制，[戳这里了解详情](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-jsp-limitations)。至于说其它的模板引擎怎么选择，这就是萝卜青菜各有所爱了，网上也有好多比较究竟是用哪个比较好的这种文章，自己权衡吧，本站使用 Thymeleaf 是因为它是基于 HTML 的标签语言，可以和 HTML 很好的结合，可以直接在浏览器里打开模板文件，即使没有值也不会导致 HTML 结构错误，而其他模板不行。总之，没有最好，只有最适合。

默认 Spring 会在 Class Path 下从以下目录中寻找模板文件：`/templates`。

默认 Spring 会在 Class Path 下从以下目录中寻找静态资源，`/static`，`/public`，`/resources`，`/META-INF/resources`。

> 所以一个完整的目录结构看起来是这样的：

```html
blog
 +- src
    +- main
    		+- java
    		+- resources
    			+- static
    			+- templates
    			+- public
    			application.properties
					...
    +- test
			+- java
			+- ...
		
```

static 目录下可以存放所有静态资源，比如 js、css 等，public 下可以存放图片、音频、视频等等。

当然，这只是默认的配置，也可以通过修改配置文件来更改自己的路径。



## IDEA 创建 SpringBoot 项目

**IDEA** 集成了 **Spring Initialzr** 可以方便的创建 **SpringBoot** 项目，[戳这里看详情](https://www.jetbrains.com/help/idea/spring-boot.html#top)。有一个称心入手的开发工具，能使你身心愉悦的进行开发，在开发过程当中，本来就有很多恼人的事情，不想做却不得不做的事情，很多事除非你跳槽，否则你就必须接受，那为什么不让自己有一个开发利器来提升自己的效率，让自己开心一点呢？又不用你花钱，不用你花大量时间，花几分钟就可以开始用了，花个十天半月就熟悉了。总之，从 Eclipse 转到 IDEA，就好比从安卓手机转到苹果手机，刚开始可能会由于陌生而不习惯，等用熟了，就再也不想回去了。就是这种感觉，嗯，是的。

本着节省的原则本站，几乎不使用图片来举例，尽量使用外链到官方地址。而且，博主认为，学任何一个新的东西或者工具，都需要具有基本的知识，比如用 **SpringBoot**，她本身只是一个工具，一个框架，她只是让你更好的使用 **Spring Framework，Spring Security，Spring Data JPA** 等等，所以前提还是需要先学会如何使用这些东西，才能体会到 **SpringBoot** 带来的好处。

本系列教程，会结合 **SpringBoot** 在涉及到某一个具体的框架时，结合两者会有详细的描述。






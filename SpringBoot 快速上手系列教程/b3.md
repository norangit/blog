# SpringBoot 快速上手系列教程（三）



**SpringBoot** 是 **Spring** 官方为了简化开发难度，提升开发效率而打磨的一个造福开发者的全能框架，她天生就是为集成而来，方便集成，快速集成，自动集成。她提供了很多本是生产环境才具有的特性，比如应用监控，代码热修改等。本篇主要介绍配更加详细的置文件，**Profile** 使用，以及 **SpringMVC** 中常用的一些基本配置，如：文件上传，JSON 映射，单元测试。



## SpringBoot 主要配置文件

**SpringBoot** 会从以下位置加载 `application.properties` 配置文件，并添加到 `Environment` 对象中：

1. 当前目录的子目录` /config`
2. 当前目录
3. 当前 `classpath` 下的 `/config`
4. 当前 `classpath` 根路径下

`注意：以上顺序优先级 1 > 4`

当然也可以通过 `spring.config.location` 来指定配置文件的路径，但是需要注意的是，因为 **SpringBoot** 需要及早地知道配置文件的位置，以便于加载配置文件执行初始化，所以需要通过以下几种方式来指定 `spring.config.location` ：

1. 系统环境变量，变量名=变量值 `spring.config.location=...`
2. 系统属性，在 **Main** 方法里 `SpringApplication.run(BlogApp.class, args)`  之前，`System.setProperty("spring.config.location", "...")`
3. 命令行参数 `java -jar myproject.jar --spring.config.location=...`

如果通过以上 3 种方式之一指定了 `spring.config.location` 的值，则查找顺序就按照指定的路径查找，默认的查找路径不再生效。如果需要默认的查找路径也生效，则可以通过指定 `spring.config.additional-location` 来达到只是额外增加配置，而不是覆盖默认的配置效果。如 `spring.config.additional-location=./config1/`，则查找顺序为：

1. 当前目录的子目录 `/config1`
2. 当前目录的子目录` /config`
3. 当前目录
4. 当前 `classpath` 下的 `/config`
5. 当前 `classpath` 根路径下

这样做的好处显而易见，万一自定义路径没有发现，则使用默认的。缺点也显而易见，本来是想自定义路径的，如果没找到就应该启动失败，自己根据实际情况决定。

`注意：如果自定义的路径是一个目录，则需要以斜杠 '/' 结尾。`



> 使用 **Profile**，动态选择配置文件

实际项目中，开发、测试、生产环境都有单独的配置文件，这时候就可以通过 **Profile** 来实现，**SpringBoot** 会查找格式为 `application-{profile}.properties` 这样的配置文件，默认的 **profile** 的值是 **default**，即：**application-default.properties**，如果连 **application-default.properties** 也没有找到，则使用 **application.properties**，这样就可以有：

1. `application.properties`
2. `application-test.properties`
3. `application-prod.properties`

可以通过命令行启动参数 

`java -jar -Dspring.profiles.active=prod xxx.jar`

或者 Maven 配置文件 pom:

```xml
<profiles>
  <profile>
    <id>prod</id>
    <properties>
      <activated.properties>prod</activated.properties>
      <scope.provided>provided</scope.provided>
    </properties>
  </profile>

  <profile>
    <id>dev</id>
    <activation>
      <activeByDefault>true</activeByDefault>
    </activation>

    <properties>
      <activated.properties></activated.properties>
      <scope.provided>compile</scope.provided>
    </properties>
  </profile>
</profiles>
```

然后也可以在 `application.properties` 文件中，通过表达式 `logging.config=classpath:log4j2-spring-@activated.properties@.xml` 来引用该变量。如上则会使用 `application-prod.properties` 配置文件，`log4j2-spring-prod.xml` 日志配置文件。在 Maven 打包的时候指定参数 P 即可：`mvn clean package -P prod`。



至于说选择使用命令行参数还是选择 **Maven**，取决于是以 war 包方式启动还是以 `jar` 包启动，以 `war` 包启动的话通常都是把 war 包放在 `webapps` 目录下，应用服务器会自动检测，这种情况下就需要以 **Maven** 的方式来配置了。

如果以 jar 包方式启动，效果都一样。简单就是美，光一个配置文件就有这么多的选择，真的是有点头大，如果可以，尽可能的使用默认配置，能省去好多尴尬的问题，能不作就不作，当然学习能力强的可以忽略。

更加详细的配置属性列表，请参考 [SpringBoot 官方提供的属性列表](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix)。



## SpringMVC

**SpringBoot** 提供的一些 **Starter** 里包含了 **SpringMVC** 依赖，而不是直接包含 jar 包在里面，可以参考官方文档查看[详细原因](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-spring-mvc)。

>JSON 处理

对于请求响应以 `JSON`，`XML` 为格式的，**SpringBoot** 如果发现 **Jackson** 存在于 `classpath`，则默认使用 **Jackson**，并自动创建一个默认的 **ObjectMapper**，且具有以下默认属性：

1. `MapperFeature.DEFAULT_VIEW_INCLUSION` 为 `false`
2. `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES` 为 `false`
3. `SerializationFeature.WRITE_DATES_AS_TIMESTAMPS` 为 `false`



**SpringBoot** 提供了以下对应的配置，

| Enum                                                    | Property                                        | Values                                                       |
| :------------------------------------------------------ | ----------------------------------------------- | :----------------------------------------------------------- |
| `com.fasterxml.jackson.databind.DeserializationFeature` | `spring.jackson.deserialization.<feature_name>` | `true`, `false`                                              |
| `com.fasterxml.jackson.core.JsonGenerator.Feature`      | `spring.jackson.generator.<feature_name>`       | `true`, `false`                                              |
| `com.fasterxml.jackson.databind.MapperFeature`          | `spring.jackson.mapper.<feature_name>`          | `true`, `false`                                              |
| `com.fasterxml.jackson.core.JsonParser.Feature`         | `spring.jackson.parser.<feature_name>`          | `true`, `false`                                              |
| `com.fasterxml.jackson.databind.SerializationFeature`   | `spring.jackson.serialization.<feature_name>`   | `true`, `false`                                              |
| `com.fasterxml.jackson.annotation.JsonInclude.Include`  | `spring.jackson.default-property-inclusion`     | `always`, `non_null`, `non_absent`, `non_default`, `non_empty` |

属性名称是大小写不敏感的，如：

```properties
spring.jackson.serialization.fail_on_empty_beans=false
#fail_on_empty_beans 对应 com.fasterxml.jackson.databind.SerializationFeature 中的FAIL_ON_EMPTY_BEANS(true)
```

关于 **Jackson** 的更多详细使用可以参考[官方文档](https://github.com/FasterXML/jackson)。

也有人会用到 `fastjson`，看个人喜好了，`fastjson` 官方也给出了性能对比。



> 文件上传

**SpringBoot** 官方推荐使用容器提供的文件上传功能，而不是使用像 `Apache Commons File Upload` 这样的第三方依赖，默认的文件上传限制为，单文件不超过 1MB，单次请求不超过 10MB。可以通过参数配置大小：

```properties
spring.servlet.multipart.max-file-size=2MB
spring.servlet.multipart.max-request-size=20MB
```



> 单元测试

即使有了像 **JRebel** 这样强大的代码热替换插件，在实际项目中也不能不写单元测试，除非是一个小项目，或自己的一个博客，比如本站，我写的单元测试寥寥无几，写多了也没有意义，我也不需要代码覆盖率测试，线上出现问题也可以随时重新部署。实际项目中，有的项目要求很严格，要求测试覆盖率达到 70 以上，甚至更高，甚至要求 Dao、Service、Controller 都要写。

**SpringBoot** 提供了测试的 **Starter**  `spring-boot-starter-test`，包含了以下依赖：[JUnit 5](https://junit.org/junit5/) 、[Spring Test](https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/testing.html#integration-testing) 、[AssertJ](https://assertj.github.io/doc/)、[Hamcrest](https://github.com/hamcrest/JavaHamcrest)、[Mockito](https://site.mockito.org/)、[JSONassert](https://github.com/skyscreamer/JSONassert)、[JsonPath](https://github.com/jayway/JsonPath)，如果不满足自己的场景，可以自己添加依赖。

**SpringBoot** 提供了一个注解 `@SpringBootTest` 来跑单元测试用例。在测试 web 应用的时候，默认不会启动 `Server`，可以通过注解属性 `webEnvironment` 来指定想要的行为，`webEnvironment` 的值有：

1. **MOCK**：默认值。提供 `ApplicationContext` 并模拟一个 web 环境。嵌入式的 `Server` 入 **Tomcat** 不会启动，如果当前应用非 web 应用，则自动切换为非 web 环境。
2. **RANDOM_PORT**：提供 `WebServerApplicationContext` 并启动真实的 `Web Server`，监听在随机端口上。
3. **DEFINED_PORT**：提供 `WebServerApplicationContext` 并启动真实的 `Web Server`，监听在指定端口上，从 配置文件读取指定的端口，如果没有配置，默认使用 `8080`。

如果测试用例是启用事务的，**SpringBoot** 默认会在（即：`webEnvironment=MOCK`）单元测试方法执行完毕后自动回滚事务，所以你会发现你跑了 N 次测试用例，也看到控制台打印 `sql` 了，但数据库里就是没有数据。禁止事务回滚，可以添加注解 `@Rollback(false)` 。可以添加到类上，禁止当前类及子类的所有方法，也可以添加到方法上，只禁止当前方法事务回滚。

栗子：

```java
@SpringBootTest
@Rollback(false)
//@RunWith(SpringRunner.class) 如果使用 JUnit4，需要打开此行注释
class StatServiceTest {

    @Autowired
    private BlogService blogService;

    @Test
    //@Rollback(false)
    void save() {
        Blog blog = blogService.getById(2L);
				blogService.delete(blog);
    }
}
```



### 结论

本系列 **SpringBoot** 快速上手共 3 篇，篇幅虽小，但却涵盖了开发一个项目基本必备的技能点，对于初学者来说，既容易理解，快速上手开始开发一个中小项目，又可以对于 **SpringBoot** 开发有一个大概的比较全面的了解，她只是一个粘合剂，高度自动化的集成工具，并不提供具体的某一个框架实现，具体的技术还需要参考具体的官方文档。**Spring** 社区这么多年来，社区提供的官方文档还是比较详细的，更加细节的东西就需要自己读源码，作为一个初中级开发者，是不需要做到这么深入的，当然，如果有能力者另说。毕竟，还是普通人多。想成为一个大神，不是那么容易的。路漫漫其修远兮，远兮，慢慢来吧。学习她，没有捷径，除了智商高以外，就是找到一个适合自己的最佳学习方法。跟长跑一样，不要光看起步快，还需要毅力，坚持，才能达到目的。

### 系列教程

* [SpringBoot 快速上手系列教程（一)](https://gxfcba.com/a1/blog/5)
* [SpringBoot 快速上手系列教程（二)](https://gxfcba.com/a1/blog/7)


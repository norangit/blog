# SpringSecurity 最佳实践系列（一）

**Spring Security** 是 **Spring** 官方出品的一个关于应用安全方面的框架，是一个功能强大且高度可定制的安全身份认证和访问控制框架。它是一个事实上的基于 **Spring** 应用程序的安全规范标准。几乎每一个应用程序都需要考虑安全，简单的如登陆认证，复杂的如方法级别的权限管理等。 **Spring Security** 是一个安全框架，致力于为 `Java` 应用程序提供身份认证和授权。与所有的 **Spring** 官方提供的项目一样，**Spring Security** 的真正强大之处在于它很容易扩展，以满足定制化的需求。

**Spring Security** 【5.1.X】具有以下特性：

* 全面的、可扩展的身份认证和授权支持

* 攻击防护，如会话固定攻击，点击劫持，跨站请求伪造等

* **Servlet API** 集成

* 可选的 **Spring Web MVC** 集成

* 更多。。。

  

## 快速上手

可以参考官方文档快速构建一个简单的 **SpringBoot** 应用，[戳这里](https://start.spring.io/)，然后下载下来解压，导入到 IDE 里，推荐使用 [IDEA](https://www.jetbrains.com/idea/download/)，博主也是从 **Eclipse** 转到 **IDEA** 的，比起 **Eclipse** 来非常好用，非常强大。 有社区免费版，也有旗舰版。

`极力推荐使用 IDEA` （[可以戳这里查看如何科学使用](https://gxfcba.com/a1/softRes)）。

**Maven** 依赖：

```xml
<dependencies>
    <!-- ... 其它依赖 ... -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```



> **SpringBoot** 自动配置会自动地：

* 启用 **Spring Security** 的默认配置，即：创建一个 **Java Bean** 名字为 `springSecurityFilterChain`  的 **Servlet Filter**。 这个 **Bean** 负责应用的所有安全，保护应用的所有 URL，验证提交的用户名密码，重定向到登陆页面，等等。
* 创建一个 **UserDetailsService**，默认的用户名为 `user`，以及一个随机生成的密码
* 注册 **springSecurityFilterChain Bean** 到 `Servlet` 容器中，并应用到每一个请求。
* 对于任何请求都要求有一个被认证的用户
* 为你生成一个默认的登陆页面
* 密码加密格式为 **BCrypt**
* 用户登出
* [CSRF 保护](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)
* [会话固定攻击保护](https://en.wikipedia.org/wiki/Session_fixation)
* 安全 `HTTP Header` 响应头集成：
  1. [HTTP Strict Transport Security](https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8) 严格传输安全
  2. [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx) 内容安全集成
  3. 缓存控制
  4. [X-XSS-Protection](https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx) 跨站脚本攻击
  5. `X-Frame-Options` 集成以保护[点击劫持](https://zh.wikipedia.org/wiki/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81)
* 集成了以下方法到 Servlet API ：
  1. [`HttpServletRequest#getRemoteUser()`](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser())
  2. [`HttpServletRequest.html#getUserPrincipal()`](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal())
  3. [`HttpServletRequest.html#isUserInRole(java.lang.String)`](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String))
  4. [`HttpServletRequest.html#login(java.lang.String, java.lang.String)`](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String, java.lang.String))
  5. [`HttpServletRequest.html#logout()`](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout())



> ​	**Security Filters** 安全过滤器

**Spring Security** 默认提供了很多安全过滤器，并且有一定的先后顺序。以下来源于官方文档：

- `ChannelProcessingFilter`
- `ConcurrentSessionFilter`
- `WebAsyncManagerIntegrationFilter`
- `SecurityContextPersistenceFilter`
- `HeaderWriterFilter`
- `CorsFilter`
- `CsrfFilter`
- `LogoutFilter`
- `OAuth2AuthorizationRequestRedirectFilter`
- `Saml2WebSsoAuthenticationRequestFilter`
- `X509AuthenticationFilter`
- `AbstractPreAuthenticatedProcessingFilter`
- `CasAuthenticationFilter`
- `OAuth2LoginAuthenticationFilter`
- `Saml2WebSsoAuthenticationFilter`
- [`UsernamePasswordAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-usernamepasswordauthenticationfilter)
- `ConcurrentSessionFilter`
- `OpenIDAuthenticationFilter`
- `DefaultLoginPageGeneratingFilter`
- `DefaultLogoutPageGeneratingFilter`
- [`DigestAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-digest)
- `BearerTokenAuthenticationFilter`
- [`BasicAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-basic)
- `RequestCacheAwareFilter`
- `SecurityContextHolderAwareRequestFilter`
- `JaasApiIntegrationFilter`
- `RememberMeAuthenticationFilter`
- `AnonymousAuthenticationFilter`
- `OAuth2AuthorizationCodeGrantFilter`
- `SessionManagementFilter`
- [`ExceptionTranslationFilter`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-exceptiontranslationfilter)
- [`FilterSecurityInterceptor`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authorization-filtersecurityinterceptor)
- `SwitchUserFilter`



实际启用的 `Filter`，可以通过 `DEBUG` 日志查看。为了便于查看日志输出，可以在浏览器地址栏访问一个应用的 URL，这样不会有额外的资源请求，比如 CSS、JS 等，或者只发一个 ajax 请求。当一个 `HTTP` 请求到达时，控制台会按照顺序依次执行 Spring Security 当前启用的 Filter。类似于下面这样的输出：

```reStructuredText
[01:11:22.293] DEBUG org.springframework.security.web.FilterChainProxy$VirtualFilterChain 328 doFilter - /blog/list at position 1 of 13 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter'
......
[01:11:22.297] DEBUG org.springframework.security.web.FilterChainProxy$VirtualFilterChain 328 doFilter - /blog/list at position 13 of 13 in additional filter chain; firing Filter: 'FilterSecurityInterceptor'
```

一共是 13 个 `Filter`，限于篇幅，这里省略了中间部分。后面会给出如何定制这些 `Filter`。



> **Authentication**认证

关于认证，**Spring Security** 提供了全面的认证支持：

- [Username and Password](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-unpwd) - 基于用户名和密码的认证（最常用的）
- [OAuth 2.0 Login](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#oauth2login) - `OAuth 2.0 OpenID Connect` 认证与非标准的 `OAuth 2.0 认证` (即：`GitHub`)
- [SAML 2.0 Login](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-saml2) - `SAML 2.0` 认证
- [Central Authentication Server (CAS)](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-cas) - `Central Authentication Server (CAS)` 认证
- [Remember Me](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-rememberme) - 记住我
- [JAAS Authentication](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-jaas) -` JAAS` 认证
- [OpenID](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-openid) - `OpenID` 认证
- [Pre-Authentication Scenarios](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-preauth) - 使用外部认证机制，如 [SiteMinder](https://www.siteminder.com/) 或者 Java EE 安全认证，**Spring Security** 相当于代理。
- [X509 Authentication](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-x509) - `X509` 认证



通常用到的认证为用户名密码认证，`OAuth` 认证，再复杂的，博主经验有限，没有实际使用过。没有去过大厂😭，也没有那么复杂的场景。

**Spring Security** 提供了一些内置对象用于 Servlet 环境中：

- [SecurityContextHolder](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-securitycontextholder) - 存放被认证用户的详细信息
- [SecurityContext](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-securitycontext) - 从 `SecurityContextHolder` 获取的，包含了当前被认证对象的信息
- [Authentication](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-authentication) - 可以是 `AuthenticationManager` 的输入，以提供用户提供的用于身份验证的凭据，也可以是 `SecurityContext` 中的当前用户
- [GrantedAuthority](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-granted-authority) - 主体的授权(即角色、范围等)。
- [AuthenticationManager](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-authenticationmanager) - 用于控制 **Spring Security** 的 `Filters` 如何进行认证
- [ProviderManager](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-providermanager) - 最基本的 `AuthenticationManager` 实现
- [AuthenticationProvider](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-authenticationprovider) - `ProviderManager` 用于执行特定类型的认证
- [Request Credentials with `AuthenticationEntryPoint`](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-authenticationentrypoint) - 用于从客户端请求凭据(即重定向到登录页面，发送 `WWW-Authenticate` 响应，等等)。
- [AbstractAuthenticationProcessingFilter](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication-abstractprocessingfilter) - 一个基本的 `Filter` 用于认证。也是一个好的切入点，便于从更高层面理解认证流程，以及这些对象如何协同工作。

其中基于用户名密码的认证 `UsernamePasswordAuthenticationFilter` 就继承自 `AbstractAuthenticationProcessingFilter`。



## 基于用户名密码的认证

实际中小项目中，基于用户名和密码的认证是最常用到的了，毕竟对于 web 应用来说，最方便的认证就是提供一个登陆页面，让用户输入用户名和密码进行验证。

事实上，**Spring Security** 提供了一个最简单的登陆页面，这个页面相当的简洁。为了页面美观、一致性，可以使用自定义的登陆页面。



继承 `WebSecurityConfigurerAdapter`，然后重写 `configure(HttpSecurity http)` 方法：

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  	@Override
    protected void configure(HttpSecurity http) throws Exception {
      http
        // 其它配置
        .formLogin(form -> form
            .loginPage("/login")
            .permitAll()
        );
    }
  
  	@Bean
    public PasswordEncoder passwordEncoder() {

        return new BCryptPasswordEncoder();
    }
}
```



Controller 方法：

```java
@RequestMapping("/login")
public String login() {
  return "login";
}
```



使用 Thymeleaf 模板，使用默认配置的情况下，上面的方法会自动查找 `src/main/resources/templates/login.html`，内容如下：

```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org">
    <head>
        <title>Login Page</title>
    </head>
    <body>
        <h1>Log In</h1>
        <form th:action="@{/login}" method="post">
            <div>
            <input type="text" name="username" placeholder="Username"/>
            </div>
            <div>
            <input type="password" name="password" placeholder="Password"/>
            </div>
            <input type="submit" value="Log in" />
        </form>
    </body>
</html>
```



自定义的 `UserDetailsService`

```java
@Service
public class MyUserDetailsService implements UserDetailsService {

    @Value("${spring.security.user.password}")
    private String defaultPassword;

    @Value("${spring.security.user.name}")
    private String defaultAdmin;

    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {				
      	//这里只是演示读取默认的配置，实际中，可以从数据库中根据传入的 username 参数查找是否当前用户存在
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
        authorities.add(new SimpleGrantedAuthority("ENDPOINT_ADMIN"));

        User user = new User(defaultAdmin, passwordEncoder.encode(defaultPassword), true, true, true, true, authorities);

        return user;
    }

    // ******** SETTER METHOD DI ********
    @Autowired
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder;
    }
}
```

如上注释，实际中，可以从数据库中根据传入的 `username` 查找是否存在对应的用户，如果存在则构建一个 `org.springframework.security.core.userdetails.User` 并返回，不存在则返回 `null`。后续的认证会自动处理。由于本站的用户认证是基于 `GitHub` 的认证，后台管理只需要有一个管理员账号就够了，所以直接配置一个就可以了。

关于密码的加密算法，使用官方推荐的 `BCryptPasswordEncoder`，在实际项目中，新建用户的时候需要对密码进行加密，数据库里存储的是密文，不需要担心泄露。关于用户名密码的认证就这么简单。

曾经见过有人在在浏览器端加密密码然后发送到后台，其实没有一点必要，如果请求真的被截获了，知道密码也没什么意义，对于个人来说，基本都用的是云服务器，买云服务器都送 `HTTPS` 证书，企业就更不用说了，所以全站启用 `HTTPS` 已经是最基本的了，足以保证数据的安全了。详细的 HTTPS 信息了解，戳这里 [HTTPS 维基百科](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE)。

### 系列教程

* [SpringSecurity 最佳实践系列（二）](https://gxfcba.com/a1/blog/10)


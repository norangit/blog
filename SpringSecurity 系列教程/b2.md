## SpringSecurity 最佳实践系列（二）

**Spring Security** 是 **Spring** 官方出品的一个关于应用安全方面的框架，是一个功能强大且高度可定制的安全身份认证和访问控制框架。它是一个事实上的基于 **Spring** 应用程序的安全规范标准。几乎每一个应用程序都需要考虑安全，简单的如登陆认证，复杂的如方法级别的权限管理等。 **Spring Security** 是一个安全框架，致力于为 `Java` 应用程序提供身份认证和授权。本篇主要介绍 Web 应用中 **Spring Security** 的 **Filter** 的使用之：`CsrfFilter`、`HeaderWriterFilter`、`UsernamePasswordAuthenticationFilter`、`LogoutFilter` 等。

### 前言

在上一篇 [SpringSecurity 最佳实践系列（一）](https://gxfcba.com/a1/blog/9)中介绍了，**Spring Security** 内置了很多的 `Filters`，在 5.X 版本中默认启用了 13 个，通过开启 **Debug** 级别的日志，可以看到详细的 `Security Filter` 日志信息。

在实际项目中，以前会自己写登陆认证，登陆 Filter 拦截所有需要登陆才能继续的请求，自己存放被认证的用户到 Session 里面等等。使用 **Spring Security** 可以免除这些工作了，主要是能和 Spring 无缝集成，最大限度的依赖 Spring 社区的力量。当然像输错密码多次则出现验证码这些功能也可以通过扩展 `UserDetailsService` 来实现。



### CSRF 跨站请求伪造攻击防护

对于 Web 应用，**Spring Security** 默认启用了 **CSRF** 保护，而且只对 POST 之类的请求生效，如 `POST`、`PUT`、`DELETE`，而对 `GET`、`HEAD`、`OPTIONS`、`TRACE` 之类的 `GET` 请求不起作用。对于 `GET` 类的请求，要求应用开发者对应用本身的方法幂等负责，即：10 次请求和 1 次请求产生的作用几乎是相等的、或者说对应用的状态不造成破坏性的改变。

> **Spring Security** 提供了 2 种方法来防止 **CSRF** 攻击

* [同步 Token 模式](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern)

  **CSRF** `Token` 应该在服务端生成，可以为每一个用户会话 - `Session` 或者每一个请求生成一次。一个请求一个 `Token` 的方式比一个用户会话一个 `Token` 的方式更安全，因为请求的次数是不定的，一个用户会话期间，可能有 N 个请求，那就有 N 个 `Token` 生成，攻击者利用 `Token` 攻击的时间就很小了。但是，这也有一个致命的缺点，就是 2 次请求的 `Token` 不同，如果该请求是需要认证的，则需要频繁认证。而一个 `Session` 一个 `Token`，则不会出现这种情况。但是被攻击的可能性就比一个请求一个 `Token` 这种的大。

  请求到达 `CSRF Filter`，如果请求不携带 `CSRF Token` 或者 `Token` 值不正确，则认证失败。

  **CSRF** `Token` 应该是被加密的、一个会话一个的、不可预测的（或者说不可破解的）。

  **CSRF** `Token` 不应该使用 `Cookie` 存放，应该使用隐藏的 input，或者 `Http Header`。

  这种模式的关键在于 **CSRF** `Token` 应该主动存在于请求中，而不是被动的（比如放在 `Cookie` 里的话，`Cookie` 的值会自动随请求被发送）。直白点说，只有同源的请求才能主动拿到服务端生成的 **CSRF** `Token`，应用开发者需要确保该 `Token` 不被泄露，这样，攻击者无法拿到 `Token`，也就无法进行 **CSRF** 攻击。

* 设置 **SameSite** 属性在 `Cookie`

  这是一种比较新的、激进的方式。服务器可以在设置 `Cookie` 里指定 **SameSite** 属性，指示如果请求来自外部站点，则不应该发送 `Cookie`。**Spring Security** 不直接设置 `Cookie`，所以也不支持这种方式。更加详细的信息[戳这里参考官方文档](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-ssa)。

  

### 登陆、登出配置

在上一篇中，介绍了自定义登陆页面。在实际项目中，在登陆成功以后除了跳转到指定页面，可能还需要做一些别的逻辑，这时候可以通过 `successHandler(AuthenticationSuccessHandler successHandler)` 方法来实现。登出成功后可能也需要做一些额外的逻辑，可以通过 `logoutSuccessHandler(LogoutSuccessHandler logoutSuccessHandler)` 来实现，如下：

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
      .anyRequest()
      .authenticated()
      .and()
      .formLogin()
      .defaultSuccessUrl("/admin")
      .loginPage("/login")
      .successHandler(mySavedRequestAwareAuthenticationSuccessHandler())
      .permitAll()
      .and()
      .logout()
      .logoutSuccessHandler(myLogoutSuccessHandler())
      .invalidateHttpSession(true)
      .deleteCookies("JSESSIONID");
}

@Bean
public SavedRequestAwareAuthenticationSuccessHandler mySavedRequestAwareAuthenticationSuccessHandler() {
  	return new MySavedRequestAwareAuthenticationSuccessHandler();
}

@Bean
public LogoutSuccessHandler myLogoutSuccessHandler() {
  	return new MyLogoutSuccessHandler();
}
```



选择 `SavedRequestAwareAuthenticationSuccessHandler` 是因为它是默认的 **SuccessHandler**，而且顾名思义，它可以记住访问登陆 URL 之前的非静态资源的 URL，实现登陆成功后自动重定向到之前的页面。比如：本来是访问 `https://gxfcba.com/a1/blog/9`，系统检测到用户没有登陆，就重定向到登陆页面，登陆成功后，系统自动重定向回 `https://gxfcba.com/a1/blog/9`，这使得用户体验更好。所以自定义一个 Handler 继承 `SavedRequestAwareAuthenticationSuccessHandler`。

`MySavedRequestAwareAuthenticationSuccessHandler.java`

```java
public class MySavedRequestAwareAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException {
      	//额外的业务逻辑，然后调用父类本身的方法
      	super.setDefaultTargetUrl("/admin");
      	super.onAuthenticationSuccess(request, response, authentication);
    }
}
```

`MyLogoutSuccessHandler.java`

```java
public class MyLogoutSuccessHandler extends AbstractAuthenticationTargetUrlRequestHandler implements LogoutSuccessHandler {

    @Override
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        //额外的业务逻辑，然后调用父类本身的方法
        //setTargetUrlParameter 的作用是告诉 Spring Security 登出成功后跳转到指定的 blogLoginUrl 参数对应的值的 url，读取自 form 表单，如下面的 html 示例
        setTargetUrlParameter("blogLoginUrl");
        super.handle(request, response, authentication);
    }

}
```

**Spring Security** 默认登出 url 为 `/logout`，在 **CSRF** 启用的情况下必须为 `post` 方法。登出的 html 表单为：

```html
<form th:action="@{/logout}" method="post">
  <input type="hidden" name="blogLoginUrl" value="/login">
  <button class="btn btn-link p-0 blog-logout-btn" type="submit">退出</button>
</form>
```

也可以通过 `addLogoutHandler(LogoutHandler logoutHandler)` 方法添加，和 `logoutSuccessHandler()` 的区别在于，后者是成功退出后才执行，比如用户信息被失效后。如果使用后者的话，需要明确指定登出成功后跳转的页面，默认的不再生效。更加详细的配置，可以参考[官方文档](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#logout-java-configuration)。



### Hi，放开那些静态资源

在一个 `Web` 应用中，静态资源，顾名思义，既然是静态资源，大部分的时候或者说都是可以开放的不受权限约束的，总之，这些不受权限约束的资源不需要经过 **Spring Security** 的系列 **Filters**，这样可以提升性能。只需要大吼一声，放开那些资源，配置一下即可，如下：

```java
@Override
public void configure(WebSecurity web) throws Exception {
	super.configure(web);

	web.ignoring()
    //把经常访问的放在最前面，能及早匹配，提升性能
    .antMatchers("/felib/**")
		.requestMatchers(PathRequest.toStaticResources().atCommonLocations());
}
```

**小技巧：** `PathRequest.toStaticResources().atCommonLocations()` 是 **Spring Security** 源码里提供的方法，看名字就能知道这个方法是收集静态资源的路径，默认为下列几个：

```html
/css/**、/js/**、/images/**、/webjars/**、/**/favicon.ico
```

这些路径的物理路径默认基于 `src/main/resources/static/` 或者 `src/main/resources/public/`，即：

```html
src/main/resources/static/css
src/main/resources/static/js
src/main/resources/static/images
src/main/resources/static/webjars
```

如果项目中有改变静态路径的话则为对应的路径，列在这里只是为了显示完整路径而已，对于 **Spring Security** 来说，在应用运行过程中，所有这些路径，都是 contextPath + '/js' 或者  contextPath + '/css' 等。 即：

`src/main/resources/static/js/base.js` 在应用运行过程中 Web 路径为 `/contextPath/js/base.js`。




### 安全相关的 HTTP Headers

**Spring Security** 默认提供了一些安全相关的 `HTTP Headers`，在实际生产环境中，通常都会前置 **Nginx** 代理，`JAVA` 应用只是在内网可访问的，所以这些 `Headers` 可以通过 **Nginx** 来配置，对于静态文件如 `JS`、`CSS`、`Images` 等也可以分离部署，这些直接通过 **Nginx** 配置就可以很容易地实现，处理静态文件是 **Nginx** 天生的特长。

对于传统的 Web 应用，如果使用 **SpringBoot** 的也是可以很方便的进行动静分离的，只需要配置 **Nginx** 就可达到动静分离的效果。对于分离式的 Web 应用，`WebPack` 更是提供了一揽子的解决方案。

所以可以在 **SpringBoot** 应用里禁用这些 `Headers`

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
http.headers().contentTypeOptions().disable().xssProtection().disable().frameOptions().disable();  
  http.authorizeRequests()
    .anyRequest()
    .authenticated()
    .and()
    .formLogin()
    .defaultSuccessUrl("/admin")
    .loginPage("/login")
    .successHandler(mySavedRequestAwareAuthenticationSuccessHandler())
    .permitAll()
    .and()
    .logout()
    .logoutSuccessHandler(myLogoutSuccessHandler())
    .invalidateHttpSession(true)
    .deleteCookies("JSESSIONID");
}
```

如果直接就是 **SpringBoot** 自带的嵌入式 `Server` 暴露在公网的话，就不能禁用掉这些 `header`。



### 结论

综上本篇所涉及到的所有配置，最终的 `Java` 配置看起来是下面这个样子的：

```java
package com.gxfcba.base.security;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private final String loginUrl = "/login";

    //如果没有配置 server.servlet.session.cookie.name，则是 JSESSIONID
    @Value("${server.servlet.session.cookie.name:'JSESSIONID'}")
    private String sessionID;

    @Override
    public void configure(WebSecurity web) throws Exception {
        super.configure(web);

        web.ignoring()
                .antMatchers("/felib/**")
                .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      	http.headers().contentTypeOptions().disable().xssProtection().disable().frameOptions().disable();

        http.authorizeRequests()
                .mvcMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest()
                .authenticated()
                .and()

                .exceptionHandling()
                .authenticationEntryPoint(new AjaxAwareAuthenticationEntryPoint(loginUrl))

                .and()
                .formLogin()
                .defaultSuccessUrl("/admin")
                .loginPage(loginUrl)
                .successHandler(mySavedRequestAwareAuthenticationSuccessHandler())
                .permitAll()
                .and()

                .logout()
                .logoutSuccessHandler(myLogoutSuccessHandler())
                .invalidateHttpSession(true)
                .deleteCookies(sessionID);

        //部分特定的 URL 禁用 CSRF
        http.csrf().ignoringAntMatchers("/druid/**");

        http.sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                .sessionFixation()
                .migrateSession()
                .maximumSessions(1);
    }

    @Bean
    public SavedRequestAwareAuthenticationSuccessHandler mySavedRequestAwareAuthenticationSuccessHandler() {
        return new MySavedRequestAwareAuthenticationSuccessHandler();
    }

    @Bean
    public LogoutSuccessHandler myLogoutSuccessHandler() {
        return new MyLogoutSuccessHandler();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

}
```



还有一个比较流行的安全框架是 [**Apache Shiro™**](https://shiro.apache.org/)，在这里不做评论，但是如果使用 **Spring** 系列技术的话，推荐使用 **Spring Security**，因为同是 **Spring** 社区项目，无缝集成。



### 系列教程

* [SpringSecurity 最佳实践系列（一）](https://gxfcba.com/a1/blog/9)

